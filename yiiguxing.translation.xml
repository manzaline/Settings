<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1724151469874" />
  </component>
  <component name="Translation.Settings">
    <option name="primaryLanguage" value="KOREAN" />
  </component>
  <component name="Translation.States">
    <option name="translationDialogHeight" value="260" />
    <option name="translationDialogLocationX" value="2339" />
    <option name="translationDialogLocationY" value="985" />
    <histories>
      <item value="Verify the encoded password obtained from storage matches the submitted raw password after it too is encoded. Returns true if the passwords match, false if they do not. The stored password itself is never decoded. Params: rawPassword – the raw password to encode and match encodedPassword – the encoded password from storage to compare with Returns: true if the raw password, after encoding, matches the encoded password from storage" />
      <item value="Service interface for encoding passwords. The preferred implementation is BCryptPasswordEncoder." />
      <item value="Implementation of PasswordEncoder that uses the BCrypt strong hashing function. Clients can optionally supply a &quot;version&quot; (2a, 2b, 2y) and a &quot;strength&quot; (a.k.a. log rounds in BCrypt) and a SecureRandom instance. The larger the strength parameter the more work will have to be done (exponentially) to hash the passwords. The default value is 10." />
      <item value="Converts a path string, or a sequence of strings that when joined form a path string, to a Path. Params: first – the path string or initial part of the path string more – additional strings to be joined to form the path string Returns: the resulting Path Throws: InvalidPathException – if the path string cannot be converted to a Path Implementation Requirements: This method simply invokes Path.of(String, String...) with the given parameters. See Also: FileSystem.getPath, Path.of(String, String...)" />
      <item value="Returns a Path by converting a path string, or a sequence of strings that when joined form a path string. If more does not specify any elements then the value of the first parameter is the path string to convert. If more specifies one or more elements then each non-empty string, including first, is considered to be a sequence of name elements and is joined to form a path string. The details as to how the Strings are joined is provider specific but typically they will be joined using the name-separator as the separator. For example, if the name separator is &quot;&quot; and getPath(&quot;foo&quot;,&quot;bar&quot;,&quot;gus&quot;) is invoked, then the path string &quot;foobargus&quot; is converted to a Path. A Path representing an empty path is returned if first is the empty string and more does not contain any non-empty strings. The Path is obtained by invoking the getPath method of the default FileSystem. Note that while this method is very convenient, using it will imply an assumed reference to the default FileSystem and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing Path instance as an anchor, such as: Path dir = ... Path path = dir.resolve(&quot;file&quot;); Params: first – the path string or initial part of the path string more – additional strings to be joined to form the path string Returns: the resulting Path Throws: InvalidPathException – if the path string cannot be converted to a Path Since: 11 See Also: FileSystem.getPath" />
      <item value="This class consists exclusively of static methods that return a Path by converting a path string or URI. API Note: It is recommended to obtain a Path via the Path.of methods instead of via the get methods defined in this class as this class may be deprecated in a future release. Since: 1.7" />
      <item value="Returns the smaller of two int values. That is, the result the argument closer to the value of Integer.MIN_VALUE. If the arguments have the same value, the result is that same value." />
      <item value="Filter base class that aims to guarantee a single execution per request dispatch, on any servlet container. It provides a doFilterInternal method with HttpServletRequest and HttpServletResponse arguments. A filter may be invoked as part of a REQUEST or ASYNC dispatches that occur in separate threads. A filter can be configured in web.xml whether it should be involved in async dispatches. However, in some cases servlet containers assume different default configuration. Therefore, subclasses can override the method shouldNotFilterAsyncDispatch() to declare statically if they should indeed be invoked, once, during both types of dispatches in order to provide thread initialization, logging, security, and so on. This mechanism complements and does not replace the need to configure a filter in web.xml with dispatcher types. Subclasses may use isAsyncDispatch(HttpServletRequest) to determine when a filter is invoked as part of an async dispatch, and use isAsyncStarted(HttpServletRequest) to determine when the request has been placed in async mode and therefore the current dispatch won't be the last one for the given request. Yet another dispatch type that also occurs in its own thread is ERROR. Subclasses can override shouldNotFilterErrorDispatch() if they wish to declare statically if they should be invoked once during error dispatches. The getAlreadyFilteredAttributeName method determines how to identify that a request is already filtered. The default implementation is based on the configured name of the concrete filter instance." />
      <item value="This method will be called whenever the SecurityContextHolder does not contain an Authentication object and Spring Security wishes to provide an implementation with an opportunity to authenticate the request using remember-me capabilities. Spring Security makes no attempt whatsoever to determine whether the browser has requested remember-me services or presented a valid cookie. Such determinations are left to the implementation. If a browser has presented an unauthorised cookie for whatever reason, it should be silently ignored and invalidated using the HttpServletResponse object. The returned Authentication must be acceptable to org.springframework.security.authentication.AuthenticationManager or org.springframework.security.authentication.AuthenticationProvider defined by the web application. It is recommended org.springframework.security.authentication.RememberMeAuthenticationToken be used in most cases, as it has a corresponding authentication provider. Params: request – to look for a remember-me token within response – to change, cancel or modify the remember-me token Returns: a valid authentication object, or null if the request should not be authenticated" />
      <item value="Implement by a class that is capable of providing a remember-me service. Spring Security filters (namely AbstractAuthenticationProcessingFilter and RememberMeAuthenticationFilter will call the methods provided by an implementation of this interface. Implementations may implement any type of remember-me capability they wish. Rolling cookies (as per https:fishbowl.pastiche.org20040119persistent_login_cookie_best_practice) can be used, as can simple implementations that don't require a persistent store. Implementations also determine the validity period of a remember-me cookie. This interface has been designed to accommodate any of these remember-me models. This interface does not define how remember-me services should offer a &quot;cancel all remember-me tokens&quot; type capability, as this will be implementation specific and requires no hooks into Spring Security. Author: Ben Alex" />
      <item value="Relying upon circular references is discouraged and they are prohibited by default. Update your application to remove the dependency cycle between beans. As a last resort, it may be possible to break the cycle automatically by setting spring.main.allow-circular-references to true." />
      <item value="| securityConfig (field private org.springframework.security.web.authentication.RememberMeServices com.example.footfix.security.config.SecurityConfig.rememberMeServices)" />
      <item value="Returns a spliterator for the elements of this stream. This is a terminal operation. The returned spliterator should report the set of characteristics derived from the stream pipeline (namely the characteristics derived from the stream source spliterator and the intermediate operations). Implementations may report a sub-set of those characteristics. For example, it may be too expensive to compute the entire set for some or all possible stream pipelines. Returns: the element spliterator for this stream" />
      <item value="A granted authority textual representation is required" />
      <item value="any" />
      <item value="Implementation of PasswordEncoder that uses the BCrypt strong hashing function. Clients can optionally supply a &quot;strength&quot; (a.k.a. log rounds in BCrypt) and a SecureRandom instance. The larger the strength parameter the more work will have to be done (exponentially) to hash the passwords. The default value is 10." />
      <item value="Defines a set of methods that a servlet uses to communicate with its servlet container, for example, to get the MIME type of a file, dispatch requests, or write to a log file. There is one context per &quot;web application&quot; per Java Virtual Machine. (A &quot;web application&quot; is a collection of servlets and content installed under a specific subset of the server's URL namespace such as catalog and possibly installed via a .war file.) In the case of a web application marked &quot;distributed&quot; in its deployment descriptor, there will be one context instance for each virtual machine. In this situation, the context cannot be used as a location to share global information (because the information won't be truly global). Use an external resource like a database instead. The ServletContext object is contained within the ServletConfig object, which the Web server provides the servlet when the servlet is initialized. See Also: Servlet.getServletConfig, ServletConfig.getServletContext" />
      <item value="Interface which allows a libraryruntime to be notified of a web application's startup phase and perform any required programmatic registration of servlets, filters, and listeners in response to it. Implementations of this interface may be annotated with HandlesTypes, in order to receive (at their onStartup method) the Set of application classes that implement, extend, or have been annotated with the class types specified by the annotation. If an implementation of this interface does not use HandlesTypes annotation, or none of the application classes match the ones specified by the annotation, the container must pass a null Set of classes to onStartup. When examining the classes of an application to see if they match any of the criteria specified by the HandlesTypes annotation of a ServletContainerInitializer, the container may run into classloading problems if any of the application's optional JAR files are missing. Because the container is not in a position to decide whether these types of classloading failures will prevent the application from working correctly, it must ignore them, while at the same time providing a configuration option that would log them. Implementations of this interface must be declared by a JAR file resource located inside the META-INFservices directory and named for the fully qualified class name of this interface, and will be discovered using the runtime's service provider lookup mechanism or a container specific mechanism that is semantically equivalent to it. In either case, ServletContainerInitializer services from web fragment JAR files excluded from an absolute ordering must be ignored, and the order in which these services are discovered must follow the application's classloading delegation model. Since: Servlet 3.0" />
      <item value="The dependencies of some of the beans in the application context form a cycle:" />
      <item value="defined" />
      <item value="Merge the state of the given entity into the current persistence context. Params: entity – entity instance Returns: the managed instance that the state was merged to Throws: IllegalArgumentException – if instance is not an entity or is a removed entity TransactionRequiredException – if there is no transaction when invoked on a container-managed entity manager of that is of type PersistenceContextType.TRANSACTION" />
      <item value="A factory for connections to the physical data source that this DataSource object represents. An alternative to the DriverManager facility, a DataSource object is the preferred means of getting a connection. An object that implements the DataSource interface will typically be registered with a naming service based on the Java Naming and Directory (JNDI) API. The DataSource interface is implemented by a driver vendor. There are three types of implementations: Basic implementation -- produces a standard Connection object Connection pooling implementation -- produces a Connection object that will automatically participate in connection pooling. This implementation works with a middle-tier connection pooling manager. Distributed transaction implementation -- produces a Connection object that may be used for distributed transactions and almost always participates in connection pooling. This implementation works with a middle-tier transaction manager and almost always with a connection pooling manager. A DataSource object has properties that can be modified when necessary. For example, if the data source is moved to a different server, the property for the server can be changed. The benefit is that because the data source's properties can be changed, any code accessing that data source does not need to be changed. A driver that is accessed via a DataSource object does not register itself with the DriverManager. Rather, a DataSource object is retrieved through a lookup operation and then used to create a Connection object. With a basic implementation, the connection obtained through a DataSource object is identical to a connection obtained through the DriverManager facility. An implementation of DataSource must include a public no-arg constructor." />
      <item value="If a value is present, performs the given action with the value, otherwise does nothing. Params: action – the action to be performed, if a value is present Throws: NullPointerException – if value is present and the given action is null" />
      <item value="element represents a range of text that is set off from the normal text for some reason, such as idiomatic text, technical terms, taxonomical designations, among others. Historically, these have been presented using italicized type, which is the original source of the &lt;i&gt; naming of this element." />
      <item value="A container object which may or may not contain a non-null value. If a value is present, isPresent() returns true. If no value is present, the object is considered empty and isPresent() returns false. Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (returns a default value if no value is present) and ifPresent() (performs an action if a value is present). This is a value-based class; programmers should treat instances that are equal as interchangeable and should not use instances for synchronization, or unpredictable behavior may occur. For example, in a future release, synchronization may fail. API Note: Optional is primarily intended for use as a method return type where there is a clear need to represent &quot;no result,&quot; and where using null is likely to cause errors. A variable whose type is Optional should never itself be null; it should always point to an Optional instance. Since: 1.8 Type parameters: &lt;T&gt; – the type of value" />
      <item value="Returns the number of pages in the set. To enable advanced printing features, it is recommended that Pageable implementations return the true number of pages rather than the UNKNOWN_NUMBER_OF_PAGES constant. Returns: the number of pages in this Pageable." />
      <item value="The Pageable implementation represents a set of pages to be printed. The Pageable object returns the total number of pages in the set as well as the PageFormat and Printable for a specified page. See Also: PageFormat, Printable" />
      <item value="Name.com is your complete source for domain names, hosting and other online presence solutions.&#10;" />
      <item value="sdfsdfsdfsdf" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="27" />
        <entry key="KOREAN" value="27" />
      </map>
    </option>
  </component>
</application>